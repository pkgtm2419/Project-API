using DLMS_CLIENT;
using System.Runtime.InteropServices;

namespace ProjectAPI._Helpers.Library
{
    public class DigitalSignature
    {
        public const byte SIZE_OF_PRIV_KEY = 32;
        public const byte SIZE_OF_PUBLIC_KEY = 64;
        public const byte SIZE_OF_PRIV_KEY_SUITE2 = 48;
        public const byte SIZE_OF_PUBLIC_KEY_SUITE2 = 96;
        public static byte[] clientPubKey = new byte[SIZE_OF_PUBLIC_KEY]{0xBA, 0xAF, 0xFD, 0xE0, 0x6A, 0x8C, 0xB1, 0xC9, 0xDA, 0xE8, 0xD9, 0x40, 0x23, 0xC6, 0x01,
                                0xDB, 0xBB, 0x24, 0x92, 0x54, 0xBA, 0x22, 0xED, 0xD8, 0x27, 0xE8, 0x20, 0xBC, 0xA2, 0xBC,
                                0xC6, 0x43, 0x62, 0xFB, 0xB8, 0x3D, 0x86, 0xA8, 0x2B, 0x87, 0xBB, 0x8B, 0x71, 0x61, 0xD2,
                                0xAA, 0xB5, 0x52, 0x19, 0x11, 0xA9, 0x46, 0xB9, 0x7A, 0x28, 0x4A, 0x90, 0xF7, 0x78, 0x5C,
                                0xD9, 0x04, 0x7D, 0x25};
        public static byte[] clientPrivKey = new byte[SIZE_OF_PRIV_KEY]{0x41, 0x80, 0x73, 0xC2, 0x39, 0xFA, 0x61, 0x25, 0x01, 0x1D, 0xE4, 0xD6, 0xCD, 0x2E, 0x64, 0x57,
                                0x80, 0x28, 0x9F, 0x76, 0x1B, 0xB2, 0x1B, 0xFB, 0x08, 0x35, 0xCB, 0x55, 0x85, 0xE8, 0xB3, 0x73};
        public static byte[] cert = new byte[379]{0x30,0x82,0x01,0x77,0x30,0x82,0x01,0x1c,0xa0,0x03,
                            0x02,0x01,0x02,0x02,0x00,0x30,0x0c,0x06,0x08,0x2a,
                            0x86,0x48,0xce,0x3d,0x04,0x03,0x02,0x05,0x00,0x30,
                            0x31,0x31,0x0e,0x30,0x0c,0x06,0x03,0x55,0x04,0x06,
                            0x13,0x05,0x49,0x4e,0x44,0x49,0x41,0x31,0x0c,0x30,
                            0x0a,0x06,0x03,0x55,0x04,0x0a,0x13,0x03,0x41,0x42,
                            0x43,0x31,0x11,0x30,0x0f,0x06,0x03,0x55,0x04,0x03,
                            0x13,0x08,0x44,0x4c,0x4d,0x53,0x20,0x44,0x45,0x50,
                            0x30,0x1e,0x17,0x0d,0x31,0x33,0x31,0x32,0x33,0x31,
                            0x32,0x33,0x35,0x39,0x35,0x39,0x5a,0x17,0x0d,0x31,
                            0x36,0x31,0x32,0x33,0x31,0x32,0x33,0x35,0x39,0x35,
                            0x39,0x5a,0x30,0x34,0x31,0x0b,0x30,0x09,0x06,0x03,
                            0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x0c,0x30,
                            0x0a,0x06,0x03,0x55,0x04,0x0a,0x13,0x03,0x58,0x59,
                            0x5a,0x31,0x17,0x30,0x15,0x06,0x03,0x55,0x04,0x03,
                            0x13,0x0e,0x53,0x4d,0x41,0x52,0x54,0x20,0x4d,0x45,
                            0x54,0x45,0x52,0x49,0x4e,0x47,0x30,0x59,0x30,0x13,
                            0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x02,0x01,0x06,
                            0x08,0x2a,0x86,0x48,0xce,0x3d,0x03,0x01,0x07,0x03,
                            0x42,0x00,0x04,0x8e,0xde,0xd7,0x8c,0xf2,0x9c,0x86,
                            0xb9,0x23,0x7a,0x12,0x32,0xf8,0xa0,0x40,0x3c,0x7b,
                            0xbb,0x77,0x51,0xaf,0x5b,0xe9,0xfe,0xcc,0x33,0x91,
                            0x76,0xbc,0x49,0xd6,0x95,0xf0,0x57,0xc7,0x4e,0x3d,
                            0x0b,0xfe,0xdf,0x78,0x09,0x45,0x60,0x30,0xf9,0x3d,
                            0xde,0xda,0xd2,0x05,0xba,0xc9,0x5e,0x0b,0x7a,0x5f,
                            0x5d,0xd0,0xea,0x84,0x05,0x8b,0xc1,0xa3,0x21,0x30,
                            0x1f,0x30,0x1d,0x06,0x03,0x55,0x1d,0x0e,0x04,0x16,
                            0x04,0x14,0x25,0x37,0x46,0xb5,0x27,0x59,0x8f,0x43,
                            0x82,0x67,0x9a,0x18,0x8e,0xb6,0x14,0x65,0x0c,0x3a,
                            0x7d,0xc2,0x30,0x0c,0x06,0x08,0x2a,0x86,0x48,0xce,
                            0x3d,0x04,0x03,0x02,0x05,0x00,0x03,0x47,0x00,0x30,
                            0x44,0x02,0x20,0x7c,0x44,0x02,0x07,0x37,0xe6,0x95,
                            0x67,0x37,0x46,0xfc,0xfb,0x54,0xcc,0x33,0xf6,0x59,
                            0xa9,0xb2,0x60,0xc8,0x6b,0x6d,0x9d,0xcf,0xf4,0x98,
                            0xad,0x4b,0x2e,0x98,0x95,0x02,0x20,0x40,0xa3,0x8d,
                            0x4f,0x62,0x96,0xea,0x5c,0x03,0x06,0xad,0x32,0x73,
                            0xb8,0xd2,0xac,0x0e,0xfc,0xb0,0xb8,0x99,0xa5,0xf9,
                            0x49,0x7c,0xdf,0x15,0xe0,0xa7,0x0a,0x9f,0xed};
        public const uint certInLen = 379;
        public static byte[] tempPublicKeyserver = new byte[SIZE_OF_PUBLIC_KEY] {0xBA, 0xAF, 0xFD, 0xE0, 0x6A, 0x8C, 0xB1, 0xC9, 0xDA, 0xE8, 0xD9, 0x40, 0x23, 0xC6, 0x01,
                                0xDB, 0xBB, 0x24, 0x92, 0x54, 0xBA, 0x22, 0xED, 0xD8, 0x27, 0xE8, 0x20, 0xBC, 0xA2, 0xBC,
                                0xC6, 0x43, 0x62, 0xFB, 0xB8, 0x3D, 0x86, 0xA8, 0x2B, 0x87, 0xBB, 0x8B, 0x71, 0x61, 0xD2,
                                0xAA, 0xB5, 0x52, 0x19, 0x11, 0xA9, 0x46, 0xB9, 0x7A, 0x28, 0x4A, 0x90, 0xF7, 0x78, 0x5C,
                                0xD9, 0x04, 0x7D, 0x25 };
        public static DLMSClient.GetSignKeysCallback getSignatureKeys = (publicUkey,
privateUkey, publicVkey, publicUkeyLen, privateUkeyLen,
publicVkeyLen, dlmsInstance, keyType, flag,
channelNo, SecuritySuite, systemTitle) =>
        {
            //return;
            //signature KEYS
            byte[] tempPublicKeyclient = new byte[SIZE_OF_PUBLIC_KEY]{0xBA, 0xAF, 0xFD, 0xE0, 0x6A, 0x8C, 0xB1, 0xC9, 0xDA, 0xE8, 0xD9, 0x40, 0x23, 0xC6, 0x01,
                                0xDB, 0xBB, 0x24, 0x92, 0x54, 0xBA, 0x22, 0xED, 0xD8, 0x27, 0xE8, 0x20, 0xBC, 0xA2, 0xBC,
                                0xC6, 0x43, 0x62, 0xFB, 0xB8, 0x3D, 0x86, 0xA8, 0x2B, 0x87, 0xBB, 0x8B, 0x71, 0x61, 0xD2,
                                0xAA, 0xB5, 0x52, 0x19, 0x11, 0xA9, 0x46, 0xB9, 0x7A, 0x28, 0x4A, 0x90, 0xF7, 0x78, 0x5C,
                                0xD9, 0x04, 0x7D, 0x25 };

            byte[] tempPrivateKey = new byte[SIZE_OF_PRIV_KEY]{ 0x41, 0x80, 0x73, 0xC2, 0x39, 0xFA, 0x61, 0x25, 0x01, 0x1D, 0xE4, 0xD6, 0xCD, 0x2E, 0x64, 0x57,
                                0x80, 0x28, 0x9F, 0x76, 0x1B, 0xB2, 0x1B, 0xFB, 0x08, 0x35, 0xCB, 0x55, 0x85, 0xE8, 0xB3, 0x73 };
            // return;
            if (flag == 0)
            {
                if (keyType == 0) //0 = publicUkey
                {
                    publicUkeyLen = 64;
                    if (tempPublicKeyserver.GetLength(0) > 0)
                    {
                        if (publicUkey != nint.Zero)
                            Marshal.Copy(tempPublicKeyserver, 0, publicUkey, tempPublicKeyserver.GetLength(0));
                    }
                }
                else if (keyType == 1) //1 = privateUkey
                {
                    privateUkeyLen = 32;
                    if (tempPrivateKey.GetLength(0) > 0)
                    {
                        if (privateUkey != nint.Zero)
                            Marshal.Copy(tempPrivateKey, 0, privateUkey, tempPrivateKey.GetLength(0));
                    }
                    //if (authMech == 7) //ues this key for ECDSA
                    //{
                    //    if (privateUkeyLen > 0 && clientPrivKey.Length == privateUkeyLen)
                    //    {
                    //        privateUkey = Marshal.AllocHGlobal(privateUkeyLen);
                    //        Marshal.Copy(clientPrivKey, 0, privateUkey, privateUkeyLen);
                    //    }
                    //}         
                }
                else //2 = publicVkey
                {
                    publicVkeyLen = 64;
                    if (publicVkey != nint.Zero)
                        Marshal.Copy(clientPubKey, 0, publicVkey, clientPubKey.GetLength(0));
                }
            }
            else if (flag == 1)
            {
                //set the public key of server with the public key got from client (contained in pointer publicUkey)
                if (keyType == 0) //0 = publicUkey
                {
                    if (publicUkey != nint.Zero)
                    {
                        Marshal.Copy(publicUkey, tempPublicKeyserver, 0, SIZE_OF_PUBLIC_KEY);
                    }
                }
            }
            return;
        };



        public static void certificateInp(ref uint certBuf_Len_CRT, ref byte[] Cert_Buf,
                                ref byte[] PrivateKey, ref byte[] PublicKey)
        {
            int i = 0;
            for (i = 0; i < 32; i++)
                PrivateKey[i] = clientPubKey[i];
            for (i = 0; i < 64; i++)
                PublicKey[i] = clientPubKey[i];
            for (i = 0; i < certInLen; i++)
                Cert_Buf[i] = cert[i];
            certBuf_Len_CRT = certInLen;
        }

        public static byte getCertificate(nint certSignLen, nint certBuffer,
            nint privKey, nint pubKey, nint dlmsInstance, ushort ChannelNo)
        {
            int i = 0;
            uint CertLen = 0;
            byte ret = 0;
            byte[] privateKey = new byte[SIZE_OF_PRIV_KEY], publicKey = new byte[SIZE_OF_PUBLIC_KEY], certBuf = new byte[500], tempBuf = new byte[5];
            nint empty = nint.Zero;

            //uses hardcoded inputs
            certificateInp(ref CertLen, ref certBuf, ref privateKey, ref publicKey);

            tempBuf[0] = (byte)CertLen;
            tempBuf[1] = (byte)(CertLen >> 8);
            // certSignLen = IntPtr.Zero;
            if (tempBuf.GetLength(0) > 0)
            {
                Marshal.Copy(tempBuf, 0, certSignLen, sizeof(int));
            }
            //certBuffer = IntPtr.Zero;
            if (certBuf.GetLength(0) > 0)
            {
                Marshal.Copy(certBuf, 0, certBuffer, certBuf.GetLength(0));
            }
            //privKey = IntPtr.Zero;
            if (privateKey.GetLength(0) > 0)
            {
                Marshal.Copy(privateKey, 0, privKey, privateKey.GetLength(0));
            }
            //pubKey = IntPtr.Zero;
            if (publicKey.GetLength(0) > 0)
            {
                Marshal.Copy(publicKey, 0, pubKey, publicKey.GetLength(0));
            }
            //you can also generate random certificate using the below function
            //ret = DLMSSecurity.computeGetDigCertCRT(certSignLen, certBuffer, privKey, pubKey, empty, 0);
            //Console.Write("Certificate len = {0:D}, cert: ", CertLen);
            //for (i = 0; i < CertLen; i++)
            //    Console.Write("{0:D} ", certBuf[i]);
            return 0;
        }
    }
}
